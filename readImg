# Student ID = 1234567
#########################Read Image#########################
.data
file: 	.asciiz	"/Users/herbyhe/Desktop/McGill/2022 Winter/Comp 273/asgn3/assign3/codes/img1.pgm"
errormsg:	.asciiz "error occured opening the file"
headerBuffer:	.space 4096	#reserve 16 char for header
tmpbuffer:	.space 4		#used to store 3digit ascii eg. '125'
readbuffer: .space 1
intbuffer:	.word 4		#used to store (int) Width,Height,Maxval
memoryErrMessage:	.asciiz "Out Of Memory\n"
space: .asciiz " "
.text
.globl read_image
#########################Read Image#########################
read_image:
	# $a0 -> input file name, it will be either P2 or P5 file
        # You need to check the char after 'P' to determine the image type. 
	################# return #####################
	# $v0 -> Image struct :
	# struct image {
	#	int width;
	#       int height;
	#	int max_value;
	#	char contents[width*height];
	#	}
	##############################################
	# Add code here
	
	#For P2 you need to use str2int 
	la $a0,file
	
	#open file
	li $v0,13
	addi $a1,$0,0	#flag=0 for read
	syscall 
	move $s0,$v0	#####s0 contains file desctript
	
	#read 2 bytes
	li $v0,14
	move $a0,$s0
	la $a1,tmpbuffer
	addi $a2,$0,3	#read 2 byte
	syscall
	#tmpbuffer should have 'P2\n' or 'P5\n'
	
	la $t0,tmpbuffer
	lb $t2,1($t0)	#t2 should be '2' or '5'
	

	#loop through headBuffer and parse out Width,Height,Maxvalue
	 addi $t6,$0,3 #t6 represent 3 infos should be read
	 la $t0,readbuffer	
	 la $a1,tmpbuffer	#a1 has the address of tmpbuffer, where its used to store '256 ' to be covnerted to int
	 la $a2,intbuffer	#$a2 points to he address where int data are stored
	 
outerloop: ble $t6,$0,outerexit	#exit if t6<=0, which we've read all infos
	move $t5,$a1	#t5 has address to tmpbuffer for ascii
innerloop:	
	#get the char
	addi $sp,$sp,-4
	sw $a1,4($sp)
	sw $a2,0($sp)
	li $v0,14
	move $a0,$s0
	la $a1,readbuffer
	addi $a2,$0,1	#reads one byte into readbuffer
	syscall
	lw $a1,4($sp)
	lw $a2,0($sp)
	addi $sp,$sp,4
	
	lb $t1,($t0)	#load char into $t1
	
	#read data if t1 is not Space or \n
	addi $t3,$0,32	#$t3 has ascii for space
	beq $t1,$t3,innerexit
	add $t3,$0,10	#t3 has ascii for \n
	beq $t1,$t3,innerexit
	#read data
	sb $t1,($t5)
	addi $t5,$t5,1	#increment pointer
	j innerloop
innerexit:	#tmpbuffer has ascii int eg.'123'
	addi $t3,$0,32	#ascii for space
	sb $t3,($t5)	#writes a spca at the end
	#now convert ascii to int
	
	addi $sp,$sp,-12
	sw $t0,12($sp)
	sw $t6,8($sp)
	sw $a1,4($sp)
	sw $a2,0($sp)
	move $a0,$a1	#move address of tmpbuffer into a0
	jal str2int	#v0 has the int val, v1 has int length
	lw $t0,12($sp)
	lw $t6,8($sp)
	lw $a1,4($sp)
	lw $a2,0($sp)
	addi $sp,$sp,8
	
	sw $v0,($a2)	#saves int val into intbufffer
	addi $a2,$a2,4	#increment pointer by a word
	addi $t6,$t6,-1	#decrement counter
	j outerloop

outerexit:#now intbuffer has width,height,maxvalue
	#t2 contains '2' or '5'
	la $t6,intbuffer
	lw $t3,($t6)	#t3 has width
	lw $t4,4($t6)	#t4 has height
	move $s4,$t3	####s4 has width
	move $s5,$t4    ####s5 has height
	lw $s6,8($t6)	###s6 has max val
	
	mult $t3,$t4	#width * height
	mflo $t3	#t3=wid*height
	addi $t3,$t3,3	#t3=width*height+3
	move $s1,$t3	# s1 has num of integers in output
	addi $t0,$0,4
	mult $t3,$t0	#	(width*height+3)*4
	mflo	$a0
	#move $s4 $a0	#### s4 has num of bytes in output
	jal malloc
	move $s2,$v0	### s2 has the address to img struct output buffer.
	#s0 has file descript

#now read all content into ascii buffer
	#li $v0,14
	#move $a0,$s0
	#move $a1,$s1
	#move $a2,$s3
	#syscall

#now ascii bufer ($s1) has all contents in pic staring from where we've read last time
	#move $t8,$s7	#t8 has address to ascii buffer where content starts
	move $t9,$s2
	#t8 now points to address where content starts
	#t9 points to int img struct output, increment by 4bytes!
	

	#loop and find the address of content
	#content starts after 3 \n
	
	##write w,h,m into output
	#s4 s5 s6 has width,heigh,maxval
	sw $s4,($t9)	#save width to output
	addi $t9,$t9,4
	sw $s5,($t9)	#save height into output
	addi $t9,$t9,4
	sw $s6,($t9)	#save max val into output
	addi $t9,$t9,4	#increment pointer to output by 4 byte
	#output has 30,14,15

	addi $t3,$0,53	#ascii for 5
	beq $t2,$t3,P5

P2:	#loop through content in ascii buffer ($t8)
	# and add to output as int $9
	
	#loop though ascii buffer and extract number (using space)
	#convert number to int
	#save number in $t9
	#should exactly reads # width*height 
	mult $s4,$s5
	mflo $t1	#t1 is the total number of pixel to read
	add $t0,$0,0	#t0 is num of pixel that has been read
	la $a3,tmpbuffer #a3 has the address to tmpbuffer used to store ascii num '123 ' 
	la $t8,readbuffer #t8 has the address to readbuffer used to store 1 byte

outerloopct: ble $t1,$t0,outerexitct #exit if $t0 >= $t1
	move $t6,$a3	##t6 has the address of tmpbuffer
innerloopct: 
	li $v0,14
	move $a0,$s0
	move $a1,$t8
	addi $a2,$0,1
	syscall		#reads a byte and store it in readbuffer
	
	lb $t3,($t8)	#load ascii from img into t3
	addi $t5,$0,32 	#ascii for space
	beq $t3,$t5,innerexitct	#exit if ascii is blank space, this means we've store the entire
	addi $t5,$0,10
	beq $t3,$t5,outerloopct
	beq $t3,$0,outerexitct	#also exit if reaches the end
	#num into tmpbuffer, and we can add ' ' and conevrt to int.
	sb $t3,($t6)	#if not a space, store ascii into tmpbuffer
	addi $t6,$t6,1	#increment pointer to tmpbuffer
	j innerloopct
innerexitct:
	#saves a space at the end
	addi $t5,$0,32 #ascii for space
	sb $t5,($t6)	#save space into tmpbuffer
	
	#now convert ascii to str
	addi $sp,$sp,-16
	sw $t0,0($sp)
	sw $t1,4($sp)
	sw $a3,8($sp)
	sw $t8,12($sp)
	sw $t9,16($sp)
	move $a0,$a3
	jal str2int
	lw $t0,0($sp)
	lw $t1,4($sp)
	lw $a3,8($sp)
	lw $t8,12($sp)
	lw $t9,16($sp)
	#$v0 has int value, store v0 into output
	sw $v0,($t9)	#save int to output
	addi $t9,$t9,4	#increment pointer by 4 bytes
	addi $t0,$t0,1	#increment counter by 1
	j outerloopct

outerexitct: #now all content has been written into img struct pointed
	#by $s2.
	j endprog

P5:
	#loop through content (lb) in in buffer ($t8)
	# and add to output as int $9 (sw)
	
	#loop though int buffer and extract number (using space)
	#save number in $t9
	#should exactly reads # width*height 
	mult $s4,$s5
	mflo $t1	#t1 is the total number of pixel to read
	add $t0,$0,0	#t0 is num of pixel that has been read


outerloopct5: ble $t1,$t0,outerexitct5 #exit if $t0 >= $t1
	lb $t3,($t8)	#load 1 byte int from img into t3
	addi $t8,$t8,1	#increment pointer to img struct
	
	sw $t3,($t9)	#save int to output
	addi $t9,$t9,4	#increment pointer to output by 4 bytes
	addi $t0,$t0,1	#increment counter by 1
	j outerloopct5

outerexitct5: #now all content has been written into img struct pointed
	#by $s2.
	j endprog


		

	
	


str2int:
	# $a0 -> address of string, i.e "32", terminated with 0, EOS
	###### returns ########
	# $v0 -> return converted integer value
	# $v1 -> length of integer
	###########################################################
	
	#loop through the string, find its length
	addi $v1,$zero,0 #$vo will contain the length
	add $t9,$0,$a0	#$t9 has the address of str, whill change
	addi $t0,$0,32

looplength:lb $t1,($t9)
	bne $t1,$t0,next
	j end

next:	addi $t9,$t9,1	#increment $t9 by 1 byte
	addi $v1,$v1,1	#increment length
	j looplength

#$v1 now contiains the length of str
end:	addi $t2,$v1,-1	#$t2 is the offset/counter
	addi $t3,$0,1	#$t3 is the multiple of 10 starting from 10^0
	addi $v0,$0,0	#v0 will have the int result of str
	addi $t4,$0,0	#will hold the str val of a byte
	addi $t5,$0,0	#$t5 will hold tmp address
	
#loop from end to start of str, and add each byte multiplied by pow of 10 to result.
#eg. '123'=3*10^0 + 2*10^1 + 3*10^2
loopint: blt $t2,$0,exit	#exit if offset <0
	add $t5,$a0,$t2		#address to load=initial address+offset
	lb $t4,($t5)		#$t4 will have char at initial address+offset
	addi $t7,$t4,-48	#convert char to decimal, put into $t7
	mult $t3,$t7		#mult $t7 digit by pow of 10
	mflo $t6	#$t6 will contain the resrult of pow of 10 * digit. Since we only consider 3 digit int, won't exceed lo.
	add $v0,$v0,$t6
	#Increment
	addi $t2,$t2,-1
	addi $t6,$0,10
	mult $t3,$t6
	mflo $t3
	j loopint

exit: j str2int.return
	
str2int.return:
	jr $ra

malloc:
	# $a0 -> number of bytes to allocate
	################## return ##################
	# $v0 -> allocated address.
  	li    	$v0, 9                 # system call code for sbrk
  	syscall                        # allocate memory
  	bnez  	$v0, malloc.return     # Did malloc fail?                   
	la 	$a0, memoryErrMessage
	li 	$v0,4
	syscall
	li	$v0,-1
malloc.return:
	jr 	$ra

endprog:move $v0,$s2
	#print img struct
	addi $t1,$0,0
printloop:	ble $s1,$t1,printend
	li $v0,1
	lw $a0,($s2)
	syscall
	addi $s2,$s2,4
	addi $t1,$t1,1
	
	li $v0,4
	la $a0,space
	syscall
	
	j printloop
printend:
	
	#return

#read_image.return:
	#jr $ra
